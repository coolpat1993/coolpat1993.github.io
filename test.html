<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Picture Tap — Simple HTML Generator</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;display:flex;gap:20px;padding:20px}
    .panel{width:420px}
    label{display:block;margin:8px 0 4px;font-weight:600}
    input[type=text], select, button{width:100%;padding:8px;margin-bottom:8px;border-radius:6px;border:1px solid #ccc}
    canvas{background:#111;border-radius:8px;display:block;width:384px;height:552px}
    .controls{display:flex;gap:8px}
    .controls button{flex:1}
    .small{font-size:13px;color:#555}
    ul{padding-left:18px}
    .coord-list{max-height:200px;overflow:auto;background:#f8f8f8;padding:8px;border-radius:6px}
    .hint{font-size:12px;color:#666}
    .row{display:flex;gap:8px}
    .row > *{flex:1}
  </style>
</head>
<body>
  <div class="panel">
    <h2>Picture Tap Generator</h2>
    <p class="small">Create QQ_ filenames with percentage coordinates and export image at <strong>640×920</strong>.</p>

    <label>Upload image</label>
    <input id="file" type="file" accept="image/*">

    <label>Question / Title</label>
    <input id="title" type="text" placeholder="Tap on the Eiffel Tower" value="Tap on the Eiffel Tower">

    <label>Mode</label>
    <div class="controls">
      <button id="mode-rect">Rectangle</button>
      <button id="mode-poly">Polygon</button>
    </div>


    <label>Instructions</label>
    <div class="hint">Click on the preview to add coordinates. <strong>Rectangle:</strong> two clicks (only one rectangle allowed), then drag corner points to adjust. <strong>Polygon:</strong> multiple clicks then press Finish, then drag vertex points to adjust.</div>

    <div style="margin-top:8px;display:flex;gap:8px">
      <button id="undo">Undo last</button>
      <button id="clear">Clear</button>
    </div>

    <label>Coordinates (order matters)</label>
    <div class="coord-list" id="coords"></div>

    <label>Generated filename</label>
    <input id="generated" type="text" readonly>

    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="download">Download PNG</button>
    </div>

  </div>

  <div>
    <canvas id="canvas" width="640" height="920"></canvas>
    <div style="margin-top:8px;font-size:13px;color:#444">
      <div><strong>Preview size:</strong> 640 × 920 (export size)</div>
      <div class="small">Click coordinates shown in the list to remove them.</div>
      <div style="margin-top:8px;">
        <button id="reset-view" style="padding:6px 12px;border-radius:4px;border:1px solid #ccc;background:#f8f8f8;cursor:pointer;">Reset View</button>
        <span style="margin-left:10px;font-size:12px;color:#666;">Scroll to zoom • Middle-click drag to pan</span>
      </div>
      <div style="margin-top:8px;display:flex;align-items:center;gap:8px;">
        <span style="font-size:12px;color:#666;">Background:</span>
        <input id="bg-color" type="color" value="#222222" style="width:32px;height:24px;padding:0;border:1px solid #ccc;border-radius:4px;cursor:pointer;">
        <button id="reset-bg" style="padding:4px 8px;font-size:11px;border-radius:4px;border:1px solid #ccc;background:#f8f8f8;cursor:pointer;">Reset</button>
      </div>
    </div>
  </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const fileInput = document.getElementById('file');
const titleInput = document.getElementById('title');
const coordsDiv = document.getElementById('coords');
const generatedInput = document.getElementById('generated');
const downloadBtn = document.getElementById('download');
const modeRect = document.getElementById('mode-rect');
const modePoly = document.getElementById('mode-poly');
const undoBtn = document.getElementById('undo');
const clearBtn = document.getElementById('clear');
const resetViewBtn = document.getElementById('reset-view');
const bgColorInput = document.getElementById('bg-color');
const resetBgBtn = document.getElementById('reset-bg');
const finishPolyBtn = document.createElement('button');
finishPolyBtn.textContent = 'Finish polygon';
finishPolyBtn.style.marginTop='8px';
let mode='rect';
let img = new Image();
let imgLoaded = false;
let imageDraw = {x:0,y:0,w:640,h:920}; // the area where image is drawn inside canvas (for correct %)
let points=[]; // array of objects: {type:'point'|'rect'|'poly', coords:[{x:..,y:..},...]}
let tempPoly = []; // for polygon building
let polyFinished = false; // track if current polygon session is finished

// Transform variables for zoom and pan
let transform = {
  scale: 1.0,
  translateX: 0,
  translateY: 0
};
let isPanning = false;
let lastPanX = 0;
let lastPanY = 0;

// Helpers
function fmtPercent(v){
  // format with up to 2 decimals, trim trailing zeros
  return parseFloat((Math.round(v*100)/100).toFixed(2)).toString().replace(/\.00$/,'').replace(/([.][0-9])0$/,'$1');
}

function sanitizeTitle(t) {
  // Allow letters, numbers, spaces, hyphens, commas, and carets (no underscores or full stops)
  return t
    .replace(/[^\w\s,\-\^]/g, '')   // Remove unwanted chars except ^
    .replace(/[_\.]/g, '')          // Remove underscores and full stops
    .replace(/\s+/g, ' ')           // Collapse spaces
    .trim();
}

// Function to pad and format coordinate values for number conversion
function padCoordValue(value) {
  // Ensure value has 2 decimal places, then pad to xx.xx format
  const formatted = parseFloat(value).toFixed(2);
  const parts = formatted.split('.');
  const intPart = parts[0].padStart(2, '0'); // Pad integer part to 2 digits
  const decPart = parts[1]; // Decimal part is already 2 digits from toFixed(2)
  return intPart + decPart; // Remove decimal point by concatenating
}

// Function to convert coordinates to number string
function coordsToNumbers(coords) {
  let numberString = "";
  coords.forEach(coord => {
    const x = padCoordValue(coord.x);
    const y = padCoordValue(coord.y);
    numberString += x + y;
  });
  return numberString;
}

// Function to convert number string back to coordinates (for debugging/verification)
function numbersToCoords(numberString) {
  const coords = [];
  // Process every 8 digits (4 for x, 4 for y)
  for (let i = 0; i < numberString.length; i += 8) {
    const xPart = numberString.substr(i, 4);
    const yPart = numberString.substr(i + 4, 4);
    
    // Insert decimal point after first 2 digits
    const x = parseFloat(xPart.substr(0, 2) + '.' + xPart.substr(2));
    const y = parseFloat(yPart.substr(0, 2) + '.' + yPart.substr(2));
    
    coords.push({x, y});
  }
  return coords;
}

function updateGenerated(){
  const title = sanitizeTitle(titleInput.value || 'Your_Question');
  let allCoords = [];
  
  // Collect all coordinates from all shapes
  points.forEach(p=>{
    if(p.type==='rect' || p.type==='poly'){
      allCoords = allCoords.concat(p.coords);
    }
  });
  
  // Convert coordinates to number string
  const numberString = coordsToNumbers(allCoords);
  
  // Generate filename with number format
  const filename = `QQ_${title}_PQ${numberString}.png`;
  generatedInput.value = filename;
}

function redraw(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // fill background with selected color
  ctx.fillStyle = bgColorInput.value; 
  ctx.fillRect(0,0,canvas.width,canvas.height);
  
  // Save context and apply transform
  ctx.save();
  ctx.translate(transform.translateX, transform.translateY);
  ctx.scale(transform.scale, transform.scale);
  
  if(imgLoaded){
    // draw image into calculated draw area
    ctx.drawImage(img, imageDraw.x, imageDraw.y, imageDraw.w, imageDraw.h);
  }
  // draw existing markers (always visible in preview)
  // draw polygons/rects/points
  ctx.lineWidth=2; ctx.strokeStyle='rgba(0,100,255,0.9)'; ctx.fillStyle='rgba(0,100,255,0.9)';
    points.forEach(p=>{
      if(p.type==='rect'){
        if(p.coords.length === 1){
          // show dot for first click of rectangle
          const c = toCanvasCoords(p.coords[0]);
          ctx.beginPath(); ctx.arc(c.x,c.y,6,0,Math.PI*2); ctx.fill();
        } else if(p.coords.length === 2){
          const a = toCanvasCoords(p.coords[0]);
          const b = toCanvasCoords(p.coords[1]);
          
          // Fill the rectangle area with semi-transparent blue (editor only)
          ctx.fillStyle='rgba(0,100,255,0.3)'; 
          ctx.fillRect(a.x,a.y,b.x-a.x,b.y-a.y);
          
          // Stroke the outline
          ctx.strokeStyle='rgba(0,100,255,0.9)';
          ctx.strokeRect(a.x,a.y,b.x-a.x,b.y-a.y);
          
          // Draw corner points for moving
          ctx.fillStyle='rgba(0,100,255,0.9)'; // Reset fill style for points
          ctx.beginPath(); ctx.arc(a.x,a.y,5,0,Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(b.x,b.y,5,0,Math.PI*2); ctx.fill();
        }
      } else if(p.type==='poly'){
        if(p.coords.length>0){
          ctx.beginPath(); const first = toCanvasCoords(p.coords[0]); ctx.moveTo(first.x,first.y);
          for(let i=1;i<p.coords.length;i++){const q=toCanvasCoords(p.coords[i]); ctx.lineTo(q.x,q.y)}
          ctx.closePath(); 
          
          // Fill the polygon area with semi-transparent blue (editor only)
          ctx.fillStyle='rgba(0,100,255,0.3)'; 
          ctx.fill();
          
          // Stroke the outline
          ctx.strokeStyle='rgba(0,100,255,0.9)';
          ctx.stroke();
          
          // Draw vertex points for moving
          ctx.fillStyle='rgba(0,100,255,0.9)'; // Reset fill style for points
          p.coords.forEach(coord => {
            const c = toCanvasCoords(coord);
            ctx.beginPath(); ctx.arc(c.x,c.y,5,0,Math.PI*2); ctx.fill();
          });
        }
      }
    });

    // temp polygon in progress
    if(tempPoly.length>0){
      ctx.beginPath(); const first = toCanvasCoords(tempPoly[0]); ctx.moveTo(first.x,first.y);
      for(let i=1;i<tempPoly.length;i++){const q=toCanvasCoords(tempPoly[i]); ctx.lineTo(q.x,q.y)}
      
      // Fill temp polygon with semi-transparent cyan (if 3+ points)
      if(tempPoly.length >= 3) {
        ctx.closePath();
        ctx.fillStyle='rgba(0,255,255,0.2)'; 
        ctx.fill();
      }
      
      // Stroke the outline
      ctx.strokeStyle='rgba(0,255,255,0.9)'; 
      ctx.stroke();
      
      // Draw vertex points
      tempPoly.forEach(t=>{const c=toCanvasCoords(t); ctx.beginPath(); ctx.arc(c.x,c.y,4,0,Math.PI*2); ctx.fillStyle='rgba(0,255,255,0.9)'; ctx.fill();});
    }
  
  // Restore context
  ctx.restore();
}

function toCanvasCoords(p){
  // p has percent coords (0-100). Convert to canvas px across full canvas area
  const x = (p.x/100) * canvas.width;
  const y = (p.y/100) * canvas.height;
  return {x,y};
}

function screenToCanvas(screenX, screenY) {
  // Convert screen coordinates to canvas coordinates, accounting for transform
  const x = (screenX - transform.translateX) / transform.scale;
  const y = (screenY - transform.translateY) / transform.scale;
  return {x, y};
}

function addPointFromCanvasPx(px,py){
  // Convert screen coordinates to transformed canvas coordinates first
  const canvasCoords = screenToCanvas(px, py);
  // convert to percent relative to full canvas (640x920)
  const rx = (canvasCoords.x / canvas.width) * 100;
  const ry = (canvasCoords.y / canvas.height) * 100;
  // clamp
  const cx = Math.max(0,Math.min(100,rx));
  const cy = Math.max(0,Math.min(100,ry));
  return {x:parseFloat(cx.toFixed(2)), y:parseFloat(cy.toFixed(2))};
}

function refreshCoordsPanel(){
  coordsDiv.innerHTML = '';
  points.forEach((p,pi)=>{
    const wrapper = document.createElement('div');
    wrapper.style.padding='6px'; wrapper.style.borderBottom='1px solid #eee';
    const t = document.createElement('div'); t.style.fontWeight='600'; t.textContent = p.type.toUpperCase();
    wrapper.appendChild(t);
    const list = document.createElement('div'); list.style.fontSize='13px'; list.style.marginTop='4px';
    p.coords.forEach((c,ci)=>{
      const btn = document.createElement('button');
      btn.textContent = `(${"x"+fmtPercent(c.x)+"y"+fmtPercent(c.y)+")"}`;
      btn.style.margin='3px'; btn.style.padding='6px'; btn.style.border='1px solid #ccc'; btn.style.borderRadius='6px'; btn.onclick = ()=>{
        // remove this coordinate (if rect/poly behaves accordingly)
        if(p.type==='rect'){
          // removing one coord removes whole rect
          points.splice(pi,1);
        } else if(p.type==='poly'){
          // remove this vertex
          p.coords.splice(ci,1);
          if(p.coords.length===0) points.splice(pi,1);
        }
        updateGenerated(); refreshCoordsPanel(); redraw();
      }
      list.appendChild(btn);
    });
    wrapper.appendChild(list);
    coordsDiv.appendChild(wrapper);
  });
}

let dragInfo = null; // {shapeIndex, coordIndex, isDragging}
let justFinishedDragging = false; // Flag to prevent click after drag

// Helper function to check if click is near a point (for moving)
function findNearbyPoint(px, py, threshold = 15) {
  // Convert screen coordinates to canvas coordinates
  const canvasCoords = screenToCanvas(px, py);
  
  for(let i = 0; i < points.length; i++) {
    const shape = points[i];
    for(let j = 0; j < shape.coords.length; j++) {
      const coord = shape.coords[j];
      const canvasCoord = toCanvasCoords(coord);
      const dist = Math.sqrt((canvasCoords.x - canvasCoord.x) ** 2 + (canvasCoords.y - canvasCoord.y) ** 2);
      if(dist <= threshold / transform.scale) { // Adjust threshold for zoom level
        return {shapeIndex: i, coordIndex: j};
      }
    }
  }
  return null;
}
// events - left mouse button for drawing/dragging points
canvas.addEventListener('mousedown', (ev)=>{
  if (ev.button !== 0) return; // Only handle left mouse button
  if(!imgLoaded) return alert('Please upload an image first');
  const rect = canvas.getBoundingClientRect();
  const px = (ev.clientX - rect.left) * (canvas.width / rect.width);
  const py = (ev.clientY - rect.top) * (canvas.height / rect.height);
  
  // Check if clicking near an existing point to move it
  const nearbyPoint = findNearbyPoint(px, py);
  if(nearbyPoint) {
    dragInfo = {
      shapeIndex: nearbyPoint.shapeIndex,
      coordIndex: nearbyPoint.coordIndex,
      isDragging: false // Start as false, set to true on first move
    };
    canvas.style.cursor = 'grabbing';
    justFinishedDragging = false;
    return;
  }
  
  const pct = addPointFromCanvasPx(px,py);
  if(mode==='rect'){
    // Check if rectangle already exists
    const existingRect = points.find(p => p.type === 'rect' && p.coords.length === 2);
    if(existingRect) {
      return; // Don't allow creating another rectangle
    }
    
    // store temporarily as lastRect if one click pending
    const last = points.length>0 && points[points.length-1].type==='rect' && points[points.length-1].coords.length===1 ? points[points.length-1] : null;
    if(last){
      // complete rect
      last.coords.push(pct);
    } else {
      // start rect
      points.push({type:'rect', coords:[pct]});
    }
    updateGenerated(); refreshCoordsPanel(); redraw();
  }
  // Note: polygon handling is done in the separate click event handler
});



// Handle polygon clicks separately
canvas.addEventListener('click', (ev)=>{
  if (ev.button !== 0) return; // Only handle left mouse clicks
  if(!imgLoaded || mode !== 'poly' || polyFinished || justFinishedDragging || isPanning) return;
  
  const rect = canvas.getBoundingClientRect();
  const px = (ev.clientX - rect.left) * (canvas.width / rect.width);
  const py = (ev.clientY - rect.top) * (canvas.height / rect.height);
  
  // Don't add polygon point if we're dragging or just finished dragging
  if(dragInfo && dragInfo.isDragging) return;
  
  const pct = addPointFromCanvasPx(px,py);
  tempPoly.push(pct);
  updateGenerated(); refreshCoordsPanel(); redraw();
});

// polygon finish button behavior
finishPolyBtn.onclick = ()=>{
  if(tempPoly.length>0){
    points.push({type:'poly', coords:tempPoly.slice()});
    tempPoly = [];
    polyFinished = true; // Set flag to prevent more points
    updateGenerated(); refreshCoordsPanel(); redraw();
  }
}

// UI mode buttons
[modeRect,modePoly].forEach(btn=>btn.addEventListener('click',()=>{
  mode = btn===modeRect? 'rect' : 'poly';
  polyFinished = false; // Reset polygon finished state when switching modes
  // visual cue
  modeRect.style.opacity = mode==='rect'?1:0.6;
  modePoly.style.opacity = mode==='poly'?1:0.6;
  // toggle finish button
  if(mode==='poly'){
    if(!finishPolyBtn.isConnected) document.querySelector('.panel').appendChild(finishPolyBtn);
  } else {
    if(finishPolyBtn.isConnected) finishPolyBtn.remove();
    // if leaving poly mode, collapse temp poly into points list automatically
  }
}));
modeRect.click();

undoBtn.addEventListener('click', ()=>{
  if(mode==='poly' && tempPoly.length>0){ 
    tempPoly.pop(); 
  } else if(points.length>0) { 
    const lastShape = points[points.length-1];
    if(lastShape && lastShape.type === 'poly') {
      polyFinished = false; // Allow adding more points if we undo a polygon
    }
    points.pop();
  }
  updateGenerated(); refreshCoordsPanel(); redraw();
});
clearBtn.addEventListener('click', ()=>{ 
  points=[]; 
  tempPoly=[]; 
  polyFinished = false; // Reset polygon finished state
  updateGenerated(); refreshCoordsPanel(); redraw(); 
});

// Background color controls
bgColorInput.addEventListener('input', () => {
  redraw();
});

resetBgBtn.addEventListener('click', () => {
  bgColorInput.value = '#222222';
  redraw();
});

// file upload
fileInput.addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  img = new Image();
  img.onload = ()=>{
    imgLoaded = true;
    computeImageDraw(); redraw(); URL.revokeObjectURL(url);
  }
  img.src = url;
});

// recompute image draw area for contain behavior
function computeImageDraw(){
  const cw = canvas.width; const ch = canvas.height;
  const iw = img.width; const ih = img.height;
  const canvasRatio = cw / ch; const imgRatio = iw / ih;
  let w,h,x,y;
  if(imgRatio > canvasRatio){
    // image is wider -> fit width
    w = cw; h = Math.round(w / imgRatio); x = 0; y = Math.round((ch-h)/2);
  } else {
    // image is taller -> fit height
    h = ch; w = Math.round(h * imgRatio); y = 0; x = Math.round((cw-w)/2);
  }
  imageDraw = {x,y,w,h};
}

downloadBtn.addEventListener('click', ()=>{
  if(!imgLoaded) return alert('Please upload an image first');
  // create offscreen canvas 640x920
  const out = document.createElement('canvas'); out.width=640; out.height=920; const oc = out.getContext('2d');
  // fill bg with selected color
  oc.fillStyle=bgColorInput.value; oc.fillRect(0,0,out.width,out.height);
  // draw the image scaled the same way as preview (contain)
  // compute draw similar to computeImageDraw but scaled to out dims
  const iw = img.width, ih = img.height; const cw=out.width, ch=out.height;
  const canvasRatio = cw/ch, imgRatio = iw/ih; let w,h,x,y;
  if(imgRatio > canvasRatio){ w=cw; h=Math.round(w/imgRatio); x=0; y=Math.round((ch-h)/2); }
  else { h=ch; w=Math.round(h*imgRatio); y=0; x=Math.round((cw-w)/2); }
  oc.drawImage(img, x,y,w,h);
  // generate data url and trigger download
  const data = out.toDataURL('image/png', 0.92);
  const a = document.createElement('a'); a.href = data; a.download = generatedInput.value || 'QQ_image.png'; a.click();
});

// allow click on title to update filename
[titleInput].forEach(inp=>inp.addEventListener('input', updateGenerated));

// initial generated
updateGenerated();

// if user drags image onto canvas
['dragenter','dragover'].forEach(ev=>canvas.addEventListener(ev,(e)=>{e.preventDefault(); e.dataTransfer.dropEffect='copy';}));
canvas.addEventListener('drop',(e)=>{e.preventDefault(); const f = e.dataTransfer.files[0]; if(f){ fileInput.files = e.dataTransfer.files; const ev = new Event('change'); fileInput.dispatchEvent(ev);} });

// Zoom functionality with mouse wheel
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  // Convert to canvas coordinates before zoom
  const canvasMouseX = mouseX * (canvas.width / rect.width);
  const canvasMouseY = mouseY * (canvas.height / rect.height);
  
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  // Don't allow zooming out beyond the original scale (1.0), max zoom is 5x
  const newScale = Math.max(1.0, Math.min(5.0, transform.scale * zoomFactor));
  
  // Only apply zoom if it's different from current scale
  if (newScale !== transform.scale) {
    // Zoom toward mouse cursor
    const scaleDiff = newScale / transform.scale;
    transform.translateX = canvasMouseX - (canvasMouseX - transform.translateX) * scaleDiff;
    transform.translateY = canvasMouseY - (canvasMouseY - transform.translateY) * scaleDiff;
    transform.scale = newScale;
    
    redraw();
  }
});

// Pan functionality with middle mouse button
canvas.addEventListener('mousedown', (e) => {
  if (e.button === 1) { // Middle mouse button
    e.preventDefault();
    isPanning = true;
    const rect = canvas.getBoundingClientRect();
    lastPanX = (e.clientX - rect.left) * (canvas.width / rect.width);
    lastPanY = (e.clientY - rect.top) * (canvas.height / rect.height);
    canvas.style.cursor = 'move';
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (isPanning) {
    const rect = canvas.getBoundingClientRect();
    const currentX = (e.clientX - rect.left) * (canvas.width / rect.width);
    const currentY = (e.clientY - rect.top) * (canvas.height / rect.height);
    
    transform.translateX += currentX - lastPanX;
    transform.translateY += currentY - lastPanY;
    
    lastPanX = currentX;
    lastPanY = currentY;
    
    redraw();
    return;
  }
  
  // Original mousemove logic
  if(!imgLoaded) return;
  const rect = canvas.getBoundingClientRect();
  const px = (e.clientX - rect.left) * (canvas.width / rect.width);
  const py = (e.clientY - rect.top) * (canvas.height / rect.height);
  
  if(dragInfo) {
    if(!dragInfo.isDragging) {
      // First movement - now we're actually dragging
      dragInfo.isDragging = true;
      justFinishedDragging = false;
    }
    // Update the coordinate being dragged
    const pct = addPointFromCanvasPx(px, py);
    points[dragInfo.shapeIndex].coords[dragInfo.coordIndex] = pct;
    updateGenerated(); refreshCoordsPanel(); redraw();
  } else {
    // Check if hovering over a point
    const nearbyPoint = findNearbyPoint(px, py);
    canvas.style.cursor = nearbyPoint ? 'grab' : 'default';
  }
});

canvas.addEventListener('mouseup', (e) => {
  if (e.button === 1 && isPanning) { // Middle mouse button
    isPanning = false;
    canvas.style.cursor = 'default';
    return;
  }
  
  // Original mouseup logic
  if(dragInfo) {
    if(dragInfo.isDragging) {
      justFinishedDragging = true;
      // Use setTimeout to clear the flag after click events have processed
      setTimeout(() => {
        justFinishedDragging = false;
      }, 10);
    }
    dragInfo = null;
    canvas.style.cursor = 'default';
  }
});

// Reset view functionality
resetViewBtn.addEventListener('click', () => {
  transform.scale = 1.0;
  transform.translateX = 0;
  transform.translateY = 0;
  redraw();
});

// Prevent context menu on middle click
canvas.addEventListener('contextmenu', (e) => {
  if (e.button === 1) {
    e.preventDefault();
  }
});

</script>
</body>
</html>