<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Picture Tap ‚Äî Simple HTML Generator</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;display:flex;gap:20px;padding:20px}
    .panel{width:420px}
    label{display:block;margin:8px 0 4px;font-weight:600}
    input[type=text], select, button{width:100%;padding:8px;margin-bottom:8px;border-radius:6px;border:1px solid #ccc}
    button:disabled{opacity:0.5;cursor:not-allowed}
    canvas{background:#111;border-radius:8px;display:block;width:384px;height:552px}
    .controls{display:flex;gap:8px}
    .controls button{flex:1}
    .small{font-size:13px;color:#555}
    ul{padding-left:18px}
    .hint{font-size:12px;color:#666}
    .row{display:flex;gap:8px}
    .row > *{flex:1}
    .canvas-container{position:relative;display:inline-block}
    #reset-icon{position:absolute;top:8px;right:8px;width:32px;height:32px;background:#fff;border:1px solid #ccc;border-radius:50%;cursor:pointer;display:none;align-items:center;justify-content:center;font-size:18px;box-shadow:0 2px 4px rgba(0,0,0,0.2);transition:all 0.2s}
    #reset-icon:hover{background:#f0f0f0;transform:scale(1.1)}
    #reset-icon.visible{display:flex}
  </style>
</head>
<body>
  <div class="panel">
    <h2>Picture Tap Generator</h2>

    <input id="file" type="file" accept="image/*">

    <label>Question / Title</label>
    <input id="title" type="text" placeholder="Tap on the Eiffel Tower">

    <label>Extra Info</label>
    <input id="extraInfo" type="text" placeholder="Optional extra info">

    <label>Instructions</label>
    <div class="hint">Click anywhere on the canvas to add points. The last point added will appear <strong>orange and larger</strong>. Add 1 point for a dot, 2 points for a rectangle, or 3+ points for a polygon. <strong>Only one shape allowed</strong> - use Clear to start over. <strong>Editing:</strong> Click a point to drag it (Shift+Click to delete), or click a line segment to add a new point.</div>

    <label>Generated filename</label>
    <input id="generated" type="text" readonly>
    
    <div id="status-message" style="margin-top:8px;padding:8px;border-radius:6px;display:none;font-size:13px;"></div>

    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="download">Download PNG</button>
    </div>

  </div>

  <div>
    <div class="canvas-container">
      <canvas id="canvas" width="640" height="920"></canvas>
      <div id="reset-icon" title="Reset zoom and pan">üîç</div>
    </div>
    <div style="margin-top:8px;font-size:13px;color:#444">
      <div style="margin-top:8px;">
        <span style="font-size:12px;color:#666;">Scroll to zoom ‚Ä¢ Middle-click drag to pan</span>
      </div>
      <div style="margin-top:8px;display:flex;align-items:center;gap:8px;">
        <span style="font-size:12px;color:#666;">Background:</span>
        <input id="bg-color" type="color" value="#222222" style="width:32px;height:24px;padding:0;border:1px solid #ccc;border-radius:4px;cursor:pointer;">
      </div>
      <div style="margin-top:8px;display:flex;gap:8px;">
        <button id="undo" disabled style="flex:1;padding:8px;border-radius:6px;border:1px solid #ccc;background:#f8f8f8;cursor:pointer;">Undo</button>
        <button id="redo" disabled style="flex:1;padding:8px;border-radius:6px;border:1px solid #ccc;background:#f8f8f8;cursor:pointer;">Redo</button>
      </div>
      <div style="margin-top:8px;">
        <button id="clear" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc;background:#f8f8f8;cursor:pointer;">Clear</button>
      </div>
    </div>
  </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const fileInput = document.getElementById('file');
const titleInput = document.getElementById('title');
const extraInfoInput = document.getElementById('extraInfo');
const generatedInput = document.getElementById('generated');
const downloadBtn = document.getElementById('download');
const clearBtn = document.getElementById('clear');
const resetIcon = document.getElementById('reset-icon');
const bgColorInput = document.getElementById('bg-color');
const undoBtn = document.getElementById('undo');
const redoBtn = document.getElementById('redo');
const statusMessage = document.getElementById('status-message');
let img = new Image();
let imgLoaded = false;
let imageDraw = {x:0,y:0,w:640,h:920}; // the area where image is drawn inside canvas (for correct %)
let points=[]; // array of objects: {type:'rect'|'poly', coords:[{x:..,y:..},...]}
let currentShape = null; // The shape currently being built: {type:'rect'|'poly', coords:[...]}

// Undo/Redo history
let history = []; // Array of state snapshots
let historyIndex = -1; // Current position in history
let isUndoRedoAction = false; // Flag to prevent saving state during undo/redo

// Transform variables for zoom and pan
let transform = {
  scale: 1.0,
  translateX: 0,
  translateY: 0
};
let isPanning = false;
let lastPanX = 0;
let lastPanY = 0;

// Helpers
function fmtPercent(v){
  // format with up to 2 decimals, trim trailing zeros
  return parseFloat((Math.round(v*100)/100).toFixed(2)).toString().replace(/\.00$/,'').replace(/([.][0-9])0$/,'$1');
}

function sanitizeTitle(t) {
  // Allow letters, numbers, spaces, hyphens, commas, and carets (no underscores or full stops)
  return t
    .replace(/[^\w\s,\-\^]/g, '')   // Remove unwanted chars except ^
    .replace(/[_\.]/g, '')          // Remove underscores and full stops
    .replace(/\s+/g, ' ')           // Collapse spaces
    .trim();
}

// Function to pad and format coordinate values for number conversion
function padCoordValue(value) {
  // Ensure value has 2 decimal places, then pad to xx.xx format
  const formatted = parseFloat(value).toFixed(2);
  const parts = formatted.split('.');
  const intPart = parts[0].padStart(2, '0'); // Pad integer part to 2 digits
  const decPart = parts[1]; // Decimal part is already 2 digits from toFixed(2)
  return intPart + decPart; // Remove decimal point by concatenating
}

// Function to convert coordinates to number string
function coordsToNumbers(coords) {
  let numberString = "";
  coords.forEach(coord => {
    const x = padCoordValue(coord.x);
    const y = padCoordValue(coord.y);
    numberString += x + y;
  });
  return numberString;
}

// Function to convert number string back to coordinates (for debugging/verification)
function numbersToCoords(numberString) {
  const coords = [];
  // Process every 8 digits (4 for x, 4 for y)
  for (let i = 0; i < numberString.length; i += 8) {
    const xPart = numberString.substr(i, 4);
    const yPart = numberString.substr(i + 4, 4);
    
    // Insert decimal point after first 2 digits
    const x = parseFloat(xPart.substr(0, 2) + '.' + xPart.substr(2));
    const y = parseFloat(yPart.substr(0, 2) + '.' + yPart.substr(2));
    
    coords.push({x, y});
  }
  return coords;
}

function updateGenerated(){
  const title = sanitizeTitle(titleInput.value || 'Your_Question');
  const extraInfo = extraInfoInput.value.trim();
  let allCoords = [];
  
  // Include current shape being built (if it has at least 1 point)
  if(currentShape && currentShape.coords.length >= 1) {
    allCoords = currentShape.coords;
  }
  
  // Convert coordinates to number string
  const numberString = coordsToNumbers(allCoords);
  
  // Generate filename with number format, append extra info if present
  let filename = `QQ_${title}_PQ${numberString}`;
  if (extraInfo) {
    filename += `_${extraInfo}`;
  }
  filename += '.png';
  generatedInput.value = filename;
}

function updateResetIconVisibility(){
  // Show reset icon if canvas has been zoomed or panned
  const isTransformed = transform.scale !== 1.0 || transform.translateX !== 0 || transform.translateY !== 0;
  if(isTransformed) {
    resetIcon.classList.add('visible');
  } else {
    resetIcon.classList.remove('visible');
  }
}

function redraw(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // fill entire canvas with grey (areas outside the image)
  ctx.fillStyle = '#888888'; 
  ctx.fillRect(0,0,canvas.width,canvas.height);
  
  // Save context and apply transform
  ctx.save();
  ctx.translate(transform.translateX, transform.translateY);
  ctx.scale(transform.scale, transform.scale);
  
  if(imgLoaded){
    // fill the image area with selected background color (behind the image)
    ctx.fillStyle = bgColorInput.value; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // draw image into calculated draw area
    ctx.drawImage(img, imageDraw.x, imageDraw.y, imageDraw.w, imageDraw.h);
  }
  // draw existing markers (always visible in preview)
  // Note: finished shapes are no longer used in this version - all editing happens on currentShape

    // Draw current shape being built (all points darker blue, last point orange)
    if(currentShape && currentShape.coords.length > 0){
      ctx.lineWidth=2/transform.scale;
      ctx.strokeStyle='rgba(0,100,255,0.9)'; // Darker blue
      ctx.fillStyle='rgba(0,100,255,0.9)';
      
      if(currentShape.coords.length === 1) {
        // Show single point - make it larger and orange
        const c = toCanvasCoords(currentShape.coords[0]);
        ctx.fillStyle='rgba(255,100,0,0.9)'; // Orange for last point
        ctx.beginPath(); ctx.arc(c.x,c.y,8/transform.scale,0,Math.PI*2); ctx.fill();
      } else if(currentShape.coords.length === 2) {
        // Show as rectangle
        const a = toCanvasCoords(currentShape.coords[0]);
        const b = toCanvasCoords(currentShape.coords[1]);
        ctx.fillStyle='rgba(0,100,255,0.3)'; // Darker blue with transparency
        ctx.fillRect(a.x,a.y,b.x-a.x,b.y-a.y);
        ctx.strokeStyle='rgba(0,100,255,0.9)'; // Darker blue
        ctx.strokeRect(a.x,a.y,b.x-a.x,b.y-a.y);
        // Draw corner points - last one in orange
        ctx.fillStyle='rgba(0,100,255,0.9)'; // Darker blue
        ctx.beginPath(); ctx.arc(a.x,a.y,5/transform.scale,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(255,100,0,0.9)'; // Orange for last point
        ctx.beginPath(); ctx.arc(b.x,b.y,8/transform.scale,0,Math.PI*2); ctx.fill();
      } else {
        // Show as polygon (3+ points)
        ctx.beginPath();
        const first = toCanvasCoords(currentShape.coords[0]);
        ctx.moveTo(first.x,first.y);
        for(let i=1;i<currentShape.coords.length;i++){
          const q=toCanvasCoords(currentShape.coords[i]);
          ctx.lineTo(q.x,q.y);
        }
        ctx.closePath();
        ctx.fillStyle='rgba(0,100,255,0.2)'; // Darker blue with transparency
        ctx.fill();
        ctx.strokeStyle='rgba(0,100,255,0.9)'; // Darker blue
        ctx.stroke();
        // Draw vertex points - last one in orange and larger
        currentShape.coords.forEach((coord, idx) => {
          const c = toCanvasCoords(coord);
          const isLast = idx === currentShape.coords.length - 1;
          ctx.fillStyle = isLast ? 'rgba(255,100,0,0.9)' : 'rgba(0,100,255,0.9)'; // Darker blue
          const size = isLast ? 8 : 5;
          ctx.beginPath(); ctx.arc(c.x,c.y,size/transform.scale,0,Math.PI*2); ctx.fill();
        });
      }
    }
  
  // Restore context
  ctx.restore();
}

function toCanvasCoords(p){
  // p has percent coords (0-100). Convert to canvas px across full canvas area
  const x = (p.x/100) * canvas.width;
  const y = (p.y/100) * canvas.height;
  return {x,y};
}

function screenToCanvas(screenX, screenY) {
  // Convert screen coordinates to canvas coordinates, accounting for transform
  const x = (screenX - transform.translateX) / transform.scale;
  const y = (screenY - transform.translateY) / transform.scale;
  return {x, y};
}

function addPointFromCanvasPx(px,py){
  // Convert screen coordinates to transformed canvas coordinates first
  const canvasCoords = screenToCanvas(px, py);
  // convert to percent relative to full canvas (640x920)
  const rx = (canvasCoords.x / canvas.width) * 100;
  const ry = (canvasCoords.y / canvas.height) * 100;
  // clamp
  const cx = Math.max(0,Math.min(99.99,rx));
  const cy = Math.max(0,Math.min(99.99,ry));
  return {x:parseFloat(cx.toFixed(2)), y:parseFloat(cy.toFixed(2))};
}

let dragInfo = null; // {shapeIndex, coordIndex, isDragging, isWholeShape, startPos}
let justFinishedDragging = false; // Flag to prevent click after drag
let mouseDownHandled = false; // Flag to prevent click event when mousedown already handled the action
let editMode = false; // Track if we're in edit mode (activated by holding Shift)

// Helper functions for undo/redo
function saveState() {
  if(isUndoRedoAction) return; // Don't save during undo/redo
  
  // Create a deep copy of current state
  const state = {
    currentShape: currentShape ? JSON.parse(JSON.stringify(currentShape)) : null
  };
  
  // Remove any redo history if we're not at the end
  if(historyIndex < history.length - 1) {
    history = history.slice(0, historyIndex + 1);
  }
  
  history.push(state);
  historyIndex++;
  
  // Limit history size to 50 states
  if(history.length > 50) {
    history.shift();
    historyIndex--;
  }
  
  updateUndoRedoButtons();
}

function restoreState(state) {
  isUndoRedoAction = true;
  currentShape = state.currentShape ? JSON.parse(JSON.stringify(state.currentShape)) : null;
  
  updateGenerated();
  redraw();
  isUndoRedoAction = false;
}

function undo() {
  if(historyIndex > 0) {
    historyIndex--;
    restoreState(history[historyIndex]);
    updateUndoRedoButtons();
  }
}

function redo() {
  if(historyIndex < history.length - 1) {
    historyIndex++;
    restoreState(history[historyIndex]);
    updateUndoRedoButtons();
  }
}

function updateUndoRedoButtons() {
  undoBtn.disabled = historyIndex <= 0;
  redoBtn.disabled = historyIndex >= history.length - 1;
}

// Helper function to check if point is inside a polygon
function isPointInPolygon(px, py, coords) {
  let inside = false;
  for (let i = 0, j = coords.length - 1; i < coords.length; j = i++) {
    const xi = coords[i].x, yi = coords[i].y;
    const xj = coords[j].x, yj = coords[j].y;
    
    const intersect = ((yi > py) !== (yj > py))
        && (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

// Helper function to check if point is inside a rectangle
function isPointInRect(px, py, coord1, coord2) {
  const minX = Math.min(coord1.x, coord2.x);
  const maxX = Math.max(coord1.x, coord2.x);
  const minY = Math.min(coord1.y, coord2.y);
  const maxY = Math.max(coord1.y, coord2.y);
  return px >= minX && px <= maxX && py >= minY && py <= maxY;
}



// Helper function to calculate distance from point to line segment
function distanceToLineSegment(px, py, x1, y1, x2, y2) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  
  if (lenSq !== 0) param = dot / lenSq;
  
  let xx, yy;
  
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }
  
  const dx = px - xx;
  const dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

// Helper function to find if click is near a line segment on current shape (for adding points)
function findNearbyLineSegmentOnCurrentShape(px, py, threshold = 10) {
  if(!currentShape || currentShape.coords.length < 3) return null;
  
  const canvasCoords = screenToCanvas(px, py);
  
  for(let j = 0; j < currentShape.coords.length; j++) {
    const coord1 = currentShape.coords[j];
    const coord2 = currentShape.coords[(j + 1) % currentShape.coords.length]; // Wrap around to first point
    
    const canvasCoord1 = toCanvasCoords(coord1);
    const canvasCoord2 = toCanvasCoords(coord2);
    
    const dist = distanceToLineSegment(
      canvasCoords.x, canvasCoords.y,
      canvasCoord1.x, canvasCoord1.y,
      canvasCoord2.x, canvasCoord2.y
    );
    
    if(dist <= threshold / transform.scale) {
      return j; // Return segment index
    }
  }
  return null;
}


// events - left mouse button for drawing/dragging points
canvas.addEventListener('mousedown', (ev)=>{
  if (ev.button !== 0) return; // Only handle left mouse button
  if(!imgLoaded) return alert('Please upload an image first');
  const rect = canvas.getBoundingClientRect();
  const px = (ev.clientX - rect.left) * (canvas.width / rect.width);
  const py = (ev.clientY - rect.top) * (canvas.height / rect.height);
  
  mouseDownHandled = false; // Reset flag
  editMode = ev.shiftKey; // Activate edit mode when Shift is held
  
  // Check if we're editing the current shape
  if(currentShape && currentShape.coords.length > 0) {
    // Check if clicking on a point in current shape
    for(let i = 0; i < currentShape.coords.length; i++) {
      const coord = currentShape.coords[i];
      const canvasCoord = toCanvasCoords(coord);
      const canvasCoords = screenToCanvas(px, py);
      const dist = Math.sqrt((canvasCoords.x - canvasCoord.x) ** 2 + (canvasCoords.y - canvasCoord.y) ** 2);
      if(dist <= 15 / transform.scale) {
        if(editMode) {
          // Delete the point if in edit mode (Shift held)
          saveState(); // Save state before modifying
          currentShape.coords.splice(i, 1);
          updateGenerated(); redraw();
          mouseDownHandled = true; // Prevent click event
          return;
        } else {
          // Start dragging the point
          dragInfo = {
            coordIndex: i,
            isDragging: false
          };
          canvas.style.cursor = 'grabbing';
          justFinishedDragging = false;
          mouseDownHandled = true; // Prevent click event
          return;
        }
      }
    }
    
    // Check if clicking near a line segment to add a point (for polygons with 3+ points)
    if(currentShape.coords.length >= 3) {
      const nearbySegment = findNearbyLineSegmentOnCurrentShape(px, py);
      if(nearbySegment !== null) {
        saveState(); // Save state before adding point
        const pct = addPointFromCanvasPx(px, py);
        // Insert the new point after the first point of the segment
        const newIndex = nearbySegment + 1;
        currentShape.coords.splice(newIndex, 0, pct);
        
        updateGenerated(); redraw();
        
        // Save state after adding the point (before starting drag)
        saveState();
        
        // Immediately start dragging the newly added point
        dragInfo = {
          coordIndex: newIndex,
          isDragging: false
        };
        canvas.style.cursor = 'grabbing';
        justFinishedDragging = false;
        mouseDownHandled = true; // Prevent click event from adding another point
        
        return;
      }
    }
    
    // Check if clicking inside the shape to drag the whole shape
    if(!editMode) {
      const canvasCoords = screenToCanvas(px, py);
      const percentCoords = {
        x: (canvasCoords.x / canvas.width) * 100,
        y: (canvasCoords.y / canvas.height) * 100
      };
      
      let isInsideShape = false;
      
      // Check for rectangle (2 points)
      if(currentShape.coords.length === 2) {
        isInsideShape = isPointInRect(percentCoords.x, percentCoords.y, currentShape.coords[0], currentShape.coords[1]);
      }
      // Check for polygon (3+ points)
      else if(currentShape.coords.length >= 3) {
        isInsideShape = isPointInPolygon(percentCoords.x, percentCoords.y, currentShape.coords);
      }
      
      if(isInsideShape) {
        const pct = addPointFromCanvasPx(px, py);
        dragInfo = {
          coordIndex: null, // null indicates dragging whole shape
          isDragging: false,
          isWholeShape: true,
          startPos: pct
        };
        canvas.style.cursor = 'move';
        justFinishedDragging = false;
        mouseDownHandled = true; // Prevent click event
        return;
      }
    }
  }
});



// Handle clicks to add points
canvas.addEventListener('click', (ev)=>{
  if (ev.button !== 0) return; // Only handle left mouse clicks
  if(!imgLoaded || justFinishedDragging || isPanning || editMode || mouseDownHandled) return;
  
  const rect = canvas.getBoundingClientRect();
  const px = (ev.clientX - rect.left) * (canvas.width / rect.width);
  const py = (ev.clientY - rect.top) * (canvas.height / rect.height);
  
  // Don't add point if we're dragging or just finished dragging
  if(dragInfo && dragInfo.isDragging) return;
  
  // If no current shape, start a new one
  if(!currentShape) {
    saveState(); // Save state before starting new shape
    currentShape = {coords: []};
  } else {
    saveState(); // Save state before adding point to current shape
  }
  
  // Add the point
  const pct = addPointFromCanvasPx(px, py);
  currentShape.coords.push(pct);
  
  updateGenerated(); redraw();
});

clearBtn.addEventListener('click', ()=>{ 
  saveState(); // Save state before clearing
  currentShape = null;
  updateGenerated(); // Regenerate filename without PQ coordinates
  redraw(); 
});

// Undo/Redo button event listeners
undoBtn.addEventListener('click', undo);
redoBtn.addEventListener('click', redo);

// Keyboard shortcuts for undo/redo
document.addEventListener('keydown', (e) => {
  // Cmd+Z (Mac) or Ctrl+Z (Windows/Linux) for undo
  if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
    e.preventDefault();
    undo();
  }
  // Cmd+Shift+Z (Mac) or Ctrl+Shift+Z (Windows/Linux) for redo
  // Also support Ctrl+Y (common on Windows)
  else if (((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'z') || 
           (e.ctrlKey && e.key === 'y')) {
    e.preventDefault();
    redo();
  }
});

// Background color controls
bgColorInput.addEventListener('input', () => {
  redraw();
});


// Function to parse filename and extract question and coordinates
function parseFilename(filename) {
  // Remove .png extension
  const name = filename.replace(/\.png$/i, '');
  
  // Expected format: QQ_<title>_PQ<numbers>_<extrainfo>
  // or: QQ_<title>_PQ<numbers>
  // Also supports: 000QQ_<title>_PQ<numbers>_<extrainfo> (where 000 are numbers)
  const qqMatch = name.match(/^(?:\d+)?QQ_(.+?)_PQ(\d+)(?:_(.+))?$/);
  
  if (!qqMatch) {
    console.log('Filename does not match expected format:', filename);
    console.log('Expected format: QQ_<title>_PQ<numbers>_<extrainfo>.png or 000QQ_<title>_PQ<numbers>_<extrainfo>.png');
    return null;
  }
  
  const title = qqMatch[1];
  const numberString = qqMatch[2];
  const extraInfo = qqMatch[3] || '';
  
  // Validate that number string has valid length (multiple of 8)
  if (numberString.length === 0) {
    console.log('Empty coordinate string');
    return {
      title: title,
      extraInfo: extraInfo,
      coords: []
    };
  }
  
  if (numberString.length % 8 !== 0) {
    console.log('Invalid coordinate string length:', numberString.length, '(should be multiple of 8)');
    console.log('Coordinate string:', numberString);
    return {
      title: title,
      extraInfo: extraInfo,
      coords: []
    };
  }
  
  // Parse coordinates from number string
  const coords = numbersToCoords(numberString);
  
  console.log('‚úì Parsed filename successfully:', { 
    title, 
    extraInfo, 
    coordCount: coords.length,
    coords: coords 
  });
  
  return {
    title: title,
    extraInfo: extraInfo,
    coords: coords
  };
}

// file upload
fileInput.addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  
  // Try to parse the filename
  const parsed = parseFilename(f.name);
  if (parsed) {
    // Populate the title and extra info fields
    titleInput.value = parsed.title;
    extraInfoInput.value = parsed.extraInfo;
    
    // Set the coordinates if any
    if (parsed.coords && parsed.coords.length > 0) {
      saveState(); // Save state before importing
      currentShape = {coords: parsed.coords};
    } 
  } 
  
  const url = URL.createObjectURL(f);
  img = new Image();
  img.onload = ()=>{
    imgLoaded = true;
    computeImageDraw(); 
    updateGenerated(); // Update filename display
    redraw(); 
    URL.revokeObjectURL(url);
  }
  img.src = url;
});

// recompute image draw area for contain behavior
function computeImageDraw(){
  const cw = canvas.width; const ch = canvas.height;
  const iw = img.width; const ih = img.height;
  const canvasRatio = cw / ch; const imgRatio = iw / ih;
  let w,h,x,y;
  if(imgRatio > canvasRatio){
    // image is wider -> fit width
    w = cw; h = Math.round(w / imgRatio); x = 0; y = Math.round((ch-h)/2);
  } else {
    // image is taller -> fit height
    h = ch; w = Math.round(h * imgRatio); y = 0; x = Math.round((cw-w)/2);
  }
  imageDraw = {x,y,w,h};
}

downloadBtn.addEventListener('click', ()=>{
  if(!imgLoaded) return alert('Please upload an image first');
  // create offscreen canvas 640x920
  const out = document.createElement('canvas'); out.width=640; out.height=920; const oc = out.getContext('2d');
  // fill bg with selected color
  oc.fillStyle=bgColorInput.value; oc.fillRect(0,0,out.width,out.height);
  // draw the image scaled the same way as preview (contain)
  // compute draw similar to computeImageDraw but scaled to out dims
  const iw = img.width, ih = img.height; const cw=out.width, ch=out.height;
  const canvasRatio = cw/ch, imgRatio = iw/ih; let w,h,x,y;
  if(imgRatio > canvasRatio){ w=cw; h=Math.round(w/imgRatio); x=0; y=Math.round((ch-h)/2); }
  else { h=ch; w=Math.round(h*imgRatio); y=0; x=Math.round((cw-w)/2); }
  oc.drawImage(img, x,y,w,h);
  // generate data url and trigger download
  const data = out.toDataURL('image/png', 0.92);
  const a = document.createElement('a'); a.href = data; a.download = generatedInput.value || 'QQ_image.png'; a.click();
});

// allow click on title and extraInfo to update filename
[titleInput, extraInfoInput].forEach(inp=>inp.addEventListener('input', updateGenerated));

// initial generated
updateGenerated();

// Initialize history with empty state
saveState();

// if user drags image onto canvas
['dragenter','dragover'].forEach(ev=>canvas.addEventListener(ev,(e)=>{e.preventDefault(); e.dataTransfer.dropEffect='copy';}));
canvas.addEventListener('drop',(e)=>{e.preventDefault(); const f = e.dataTransfer.files[0]; if(f){ fileInput.files = e.dataTransfer.files; const ev = new Event('change'); fileInput.dispatchEvent(ev);} });

// Zoom functionality with mouse wheel
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  // Convert to canvas coordinates before zoom
  const canvasMouseX = mouseX * (canvas.width / rect.width);
  const canvasMouseY = mouseY * (canvas.height / rect.height);
  
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  // Don't allow zooming out beyond the original scale (1.0), max zoom is 10x
  const newScale = Math.max(1.0, Math.min(10.0, transform.scale * zoomFactor));
  
  // Only apply zoom if it's different from current scale
  if (newScale !== transform.scale) {
    // Zoom toward mouse cursor
    const scaleDiff = newScale / transform.scale;
    transform.translateX = canvasMouseX - (canvasMouseX - transform.translateX) * scaleDiff;
    transform.translateY = canvasMouseY - (canvasMouseY - transform.translateY) * scaleDiff;
    transform.scale = newScale;
    
    updateResetIconVisibility();
    redraw();
  }
});

// Pan functionality with middle mouse button
canvas.addEventListener('mousedown', (e) => {
  if (e.button === 1) { // Middle mouse button
    e.preventDefault();
    isPanning = true;
    const rect = canvas.getBoundingClientRect();
    lastPanX = (e.clientX - rect.left) * (canvas.width / rect.width);
    lastPanY = (e.clientY - rect.top) * (canvas.height / rect.height);
    canvas.style.cursor = 'move';
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (isPanning) {
    const rect = canvas.getBoundingClientRect();
    const currentX = (e.clientX - rect.left) * (canvas.width / rect.width);
    const currentY = (e.clientY - rect.top) * (canvas.height / rect.height);
    
    transform.translateX += currentX - lastPanX;
    transform.translateY += currentY - lastPanY;
    
    lastPanX = currentX;
    lastPanY = currentY;
    
    updateResetIconVisibility();
    redraw();
    return;
  }
  
  // Original mousemove logic
  if(!imgLoaded) return;
  const rect = canvas.getBoundingClientRect();
  const px = (e.clientX - rect.left) * (canvas.width / rect.width);
  const py = (e.clientY - rect.top) * (canvas.height / rect.height);
  
  editMode = e.shiftKey; // Update edit mode based on Shift key
  
  if(dragInfo) {
    if(!dragInfo.isDragging) {
      // First movement - now we're actually dragging
      dragInfo.isDragging = true;
      justFinishedDragging = false;
    }
    
    const pct = addPointFromCanvasPx(px, py);
    
    if(dragInfo.isWholeShape) {
      // Dragging entire shape - move all points by delta
      const dx = pct.x - dragInfo.startPos.x;
      const dy = pct.y - dragInfo.startPos.y;
      
      currentShape.coords = currentShape.coords.map(coord => {
        const newX = Math.max(0, Math.min(99.99, coord.x + dx));
        const newY = Math.max(0, Math.min(99.99, coord.y + dy));
        return {
          x: parseFloat(newX.toFixed(2)),
          y: parseFloat(newY.toFixed(2))
        };
      });
      
      // Update start position for next delta calculation
      dragInfo.startPos = pct;
    } else {
      // Dragging point on current shape
      currentShape.coords[dragInfo.coordIndex] = pct;
    }
    updateGenerated(); redraw();
  } else {
    // Check if hovering over a point on current shape
    if(currentShape && currentShape.coords.length > 0) {
      let foundPoint = false;
      for(let i = 0; i < currentShape.coords.length; i++) {
        const coord = currentShape.coords[i];
        const canvasCoord = toCanvasCoords(coord);
        const canvasCoords = screenToCanvas(px, py);
        const dist = Math.sqrt((canvasCoords.x - canvasCoord.x) ** 2 + (canvasCoords.y - canvasCoord.y) ** 2);
        if(dist <= 15 / transform.scale) {
          canvas.style.cursor = editMode ? 'pointer' : 'grab'; // Different cursor in edit mode
          foundPoint = true;
          break;
        }
      }
      
      if(!foundPoint) {
        // Check if hovering over a line segment on current shape (can add point)
        const nearbySegment = findNearbyLineSegmentOnCurrentShape(px, py);
        if(nearbySegment !== null) {
          canvas.style.cursor = 'crosshair';
        } else {
          // Check if hovering over the shape itself (for whole-shape dragging)
          const canvasCoords = screenToCanvas(px, py);
          const percentCoords = {
            x: (canvasCoords.x / canvas.width) * 100,
            y: (canvasCoords.y / canvas.height) * 100
          };
          
          let isInsideShape = false;
          
          // Check for rectangle (2 points)
          if(currentShape.coords.length === 2) {
            isInsideShape = isPointInRect(percentCoords.x, percentCoords.y, currentShape.coords[0], currentShape.coords[1]);
          }
          // Check for polygon (3+ points)
          else if(currentShape.coords.length >= 3) {
            isInsideShape = isPointInPolygon(percentCoords.x, percentCoords.y, currentShape.coords);
          }
          
          canvas.style.cursor = isInsideShape ? 'move' : 'default';
        }
      }
    } else {
      canvas.style.cursor = 'default';
    }
  }
});

canvas.addEventListener('mouseup', (e) => {
  if (e.button === 1 && isPanning) { // Middle mouse button
    isPanning = false;
    canvas.style.cursor = 'default';
    return;
  }
  
  // Original mouseup logic
  if(dragInfo) {
    if(dragInfo.isDragging) {
      saveState(); // Save state after dragging is complete
      justFinishedDragging = true;
      // Use setTimeout to clear the flag after click events have processed
      setTimeout(() => {
        justFinishedDragging = false;
      }, 10);
    }
    dragInfo = null;
    canvas.style.cursor = 'default';
  }
});

// Reset view functionality
resetIcon.addEventListener('click', () => {
  transform.scale = 1.0;
  transform.translateX = 0;
  transform.translateY = 0;
  updateResetIconVisibility();
  redraw();
});

// Prevent context menu on middle click
canvas.addEventListener('contextmenu', (e) => {
  if (e.button === 1) {
    e.preventDefault();
  }
});

</script>
</body>
</html>