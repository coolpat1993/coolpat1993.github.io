<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rectangle Quiz Game</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;display:flex;gap:20px;padding:20px;background:#f5f5f5}
    .panel{width:420px;background:white;padding:20px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.1)}
    label{display:block;margin:12px 0 4px;font-weight:600;color:#333}
    input[type=text], textarea{width:100%;padding:10px;margin-bottom:8px;border-radius:6px;border:1px solid #ccc;box-sizing:border-box}
    textarea{resize:vertical;min-height:60px}
    button{width:100%;padding:12px;margin-bottom:8px;border-radius:6px;border:1px solid #ccc;background:#007bff;color:white;font-weight:600;cursor:pointer;transition:background 0.2s}
    button:hover:not(:disabled){background:#0056b3}
    button:disabled{opacity:0.5;cursor:not-allowed;background:#ccc}
    button.secondary{background:#6c757d}
    button.secondary:hover:not(:disabled){background:#545b62}
    button.success{background:#28a745}
    button.success:hover:not(:disabled){background:#218838}
    canvas{background:#111;border-radius:8px;display:block;width:384px;height:552px;cursor:crosshair}
    .canvas-container{position:relative;display:inline-block;background:white;padding:20px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.1)}
    .hint{font-size:13px;color:#666;line-height:1.5;padding:8px;background:#f8f9fa;border-radius:4px;margin-bottom:12px}
    .rectangle-list{margin-top:12px}
    .rectangle-item{display:flex;align-items:center;gap:8px;padding:8px;background:#f8f9fa;border-radius:4px;margin-bottom:6px}
    .rectangle-label{font-weight:600;width:30px;color:#007bff}
    .rectangle-item input[type=checkbox]{width:auto;margin:0}
    .rectangle-item button{width:auto;padding:4px 12px;font-size:12px;margin:0}
    .mode-indicator{padding:12px;background:#007bff;color:white;border-radius:6px;margin-bottom:12px;text-align:center;font-weight:600}
    .mode-indicator.play{background:#28a745}
    .quiz-result{padding:16px;background:#d4edda;border:1px solid #c3e6cb;border-radius:6px;margin-top:12px;text-align:center}
    .quiz-result.partial{background:#fff3cd;border-color:#ffeaa7}
    .quiz-result.fail{background:#f8d7da;border-color:#f5c6cb}
    .correct-answers{margin-top:8px;font-size:13px;color:#666}
    .answer-status{font-size:13px;margin-top:8px}
    .answer-status .correct{color:#28a745;font-weight:600}
    .answer-status .incorrect{color:#dc3545;font-weight:600}
    .answer-status .missed{color:#ffc107;font-weight:600}
  </style>
</head>
<body>
  <div class="panel">
    <h2>Rectangle Quiz Game</h2>

    <div id="setup-mode">
      <div class="mode-indicator">SETUP MODE</div>
      
      <input id="file" type="file" accept="image/*">

      <label>Question</label>
      <textarea id="question" placeholder="What are the correct answers?"></textarea>

      <div class="hint">Click and drag to draw rectangles (up to 6: A-F). Drag rectangles to move them. Drag corner handles to resize. <strong>Shift+click</strong> a rectangle to delete it.</div>

      <div class="rectangle-list" id="rectangle-list">
        <div style="font-size:13px;color:#666;font-style:italic">No rectangles drawn yet</div>
      </div>

      <button id="play-quiz" class="success" disabled>Play Quiz</button>
      <button id="clear-all" class="secondary">Clear All Rectangles</button>
    </div>

    <div id="play-mode" style="display:none">
      <div class="mode-indicator play">QUIZ MODE</div>
      
      <div id="question-display" style="font-size:18px;font-weight:600;margin-bottom:16px;color:#333"></div>
      
      <div class="hint">Click on the rectangles you think are correct answers. They will highlight when you click them.</div>

      <div id="selected-display" style="margin:12px 0;padding:8px;background:#e7f3ff;border-radius:4px">
        <strong>Selected:</strong> <span id="selected-list">None</span>
      </div>

      <button id="submit-answer" class="success">Submit Answer</button>
      <button id="back-to-setup" class="secondary">Back to Setup</button>

      <div id="quiz-result" style="display:none"></div>
    </div>
  </div>

  <div>
    <div class="canvas-container">
      <canvas id="canvas" width="640" height="920"></canvas>
    </div>
  </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const fileInput = document.getElementById('file');
const questionInput = document.getElementById('question');
const playQuizBtn = document.getElementById('play-quiz');
const clearAllBtn = document.getElementById('clear-all');
const rectangleList = document.getElementById('rectangle-list');
const setupMode = document.getElementById('setup-mode');
const playMode = document.getElementById('play-mode');
const questionDisplay = document.getElementById('question-display');
const selectedDisplay = document.getElementById('selected-list');
const submitAnswerBtn = document.getElementById('submit-answer');
const backToSetupBtn = document.getElementById('back-to-setup');
const quizResult = document.getElementById('quiz-result');

let img = new Image();
let imgLoaded = false;
let imageDraw = {x:0,y:0,w:640,h:920};
let rectangles = []; // {id:'A'|'B'|'C'|'D'|'E'|'F', coords:{x1,y1,x2,y2}, isCorrect:false}
let currentMode = 'setup'; // 'setup' or 'play'
let isDrawing = false;
let drawStart = null;
let tempRect = null;
let selectedAnswers = new Set(); // For play mode
let quizSubmitted = false; // Track if quiz has been submitted
let correctAnswersSet = new Set(); // Store correct answers after submission
const labels = ['A', 'B', 'C', 'D', 'E', 'F'];
let dragMode = null; // 'move' or 'resize'
let dragRectIdx = -1;
let dragResizeCorner = null; // 'tl', 'tr', 'bl', 'br'
let dragOffset = {x: 0, y: 0};
const RESIZE_HANDLE_SIZE = 12; // pixels

// Load image
fileInput.addEventListener('change', (e)=>{
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (ev)=>{
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
});

img.onload = ()=>{
  imgLoaded = true;
  // calculate aspect-fit
  const imgAspect = img.width / img.height;
  const canvasAspect = canvas.width / canvas.height;
  if(imgAspect > canvasAspect){
    imageDraw.w = canvas.width;
    imageDraw.h = canvas.width / imgAspect;
    imageDraw.x = 0;
    imageDraw.y = (canvas.height - imageDraw.h)/2;
  } else {
    imageDraw.h = canvas.height;
    imageDraw.w = canvas.height * imgAspect;
    imageDraw.y = 0;
    imageDraw.x = (canvas.width - imageDraw.w)/2;
  }
  redraw();
};

function redraw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#222222';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  
  if(imgLoaded){
    ctx.drawImage(img, imageDraw.x, imageDraw.y, imageDraw.w, imageDraw.h);
  }
  
  // Draw existing rectangles
  rectangles.forEach((rect, idx) => {
    const coords = percentToCanvas(rect.coords);
    
    if(currentMode === 'setup'){
      // Setup mode: show all rectangles with labels
      ctx.strokeStyle = 'rgba(0,120,255,0.9)';
      ctx.lineWidth = 3;
      ctx.strokeRect(coords.x1, coords.y1, coords.x2 - coords.x1, coords.y2 - coords.y1);
      
      ctx.fillStyle = 'rgba(0,120,255,0.3)';
      ctx.fillRect(coords.x1, coords.y1, coords.x2 - coords.x1, coords.y2 - coords.y1);
      
      // Draw resize handles
      ctx.fillStyle = 'white';
      const hs = RESIZE_HANDLE_SIZE / 2;
      ctx.fillRect(coords.x1 - hs, coords.y1 - hs, RESIZE_HANDLE_SIZE, RESIZE_HANDLE_SIZE);
      ctx.fillRect(coords.x2 - hs, coords.y1 - hs, RESIZE_HANDLE_SIZE, RESIZE_HANDLE_SIZE);
      ctx.fillRect(coords.x1 - hs, coords.y2 - hs, RESIZE_HANDLE_SIZE, RESIZE_HANDLE_SIZE);
      ctx.fillRect(coords.x2 - hs, coords.y2 - hs, RESIZE_HANDLE_SIZE, RESIZE_HANDLE_SIZE);
      
      // Draw label
      ctx.fillStyle = 'white';
      ctx.font = 'bold 32px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const centerX = (coords.x1 + coords.x2) / 2;
      const centerY = (coords.y1 + coords.y2) / 2;
      ctx.fillText(rect.id, centerX, centerY);
    } else {
      // Play mode: color based on submission state
      if(!quizSubmitted){
        // Before submission: show selected in light blue
        if(selectedAnswers.has(rect.id)){
          ctx.strokeStyle = 'rgba(100,180,255,0.9)';
          ctx.lineWidth = 3;
          ctx.strokeRect(coords.x1, coords.y1, coords.x2 - coords.x1, coords.y2 - coords.y1);
          
          ctx.fillStyle = 'rgba(100,180,255,0.3)';
          ctx.fillRect(coords.x1, coords.y1, coords.x2 - coords.x1, coords.y2 - coords.y1);
        }
      } else {
        // After submission: show color-coded results
        const isCorrectAnswer = correctAnswersSet.has(rect.id);
        const wasSelected = selectedAnswers.has(rect.id);
        
        let strokeColor, fillColor, icon;
        
        if(wasSelected && isCorrectAnswer){
          // Correct selection: green with tick
          strokeColor = 'rgba(40,167,69,0.9)';
          fillColor = 'rgba(40,167,69,0.3)';
          icon = 'âœ“';
        } else if(wasSelected && !isCorrectAnswer){
          // Wrong selection: red with cross
          strokeColor = 'rgba(220,53,69,0.9)';
          fillColor = 'rgba(220,53,69,0.3)';
          icon = 'âœ—';
        } else if(!wasSelected && isCorrectAnswer){
          // Missed correct answer: orange with O
          strokeColor = 'rgba(255,165,0,0.9)';
          fillColor = 'rgba(255,165,0,0.3)';
          icon = 'â—‹';
        } else if(!wasSelected && !isCorrectAnswer){
          // Correctly didn't select (wrong answer avoided): green with tick
          strokeColor = 'rgba(40,167,69,0.9)';
          fillColor = 'rgba(40,167,69,0.3)';
          icon = 'âœ“';
        }
        
        if(strokeColor){
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = 3;
          ctx.strokeRect(coords.x1, coords.y1, coords.x2 - coords.x1, coords.y2 - coords.y1);
          
          ctx.fillStyle = fillColor;
          ctx.fillRect(coords.x1, coords.y1, coords.x2 - coords.x1, coords.y2 - coords.y1);
          
          // Draw icon in top right corner
          ctx.fillStyle = 'white';
          ctx.font = 'bold 28px sans-serif';
          ctx.textAlign = 'right';
          ctx.textBaseline = 'top';
          ctx.fillText(icon, coords.x2 - 8, coords.y1 + 8);
        }
      }
    }
  });
  
  // Draw temporary rectangle while dragging
  if(tempRect && currentMode === 'setup'){
    const coords = percentToCanvas(tempRect);
    ctx.strokeStyle = 'rgba(255,200,0,0.9)';
    ctx.lineWidth = 3;
    ctx.strokeRect(coords.x1, coords.y1, coords.x2 - coords.x1, coords.y2 - coords.y1);
    
    ctx.fillStyle = 'rgba(255,200,0,0.2)';
    ctx.fillRect(coords.x1, coords.y1, coords.x2 - coords.x1, coords.y2 - coords.y1);
  }
}

function canvasToPercent(canvasX, canvasY){
  const x = ((canvasX - imageDraw.x) / imageDraw.w) * 100;
  const y = ((canvasY - imageDraw.y) / imageDraw.h) * 100;
  return {
    x: Math.max(0, Math.min(100, x)),
    y: Math.max(0, Math.min(100, y))
  };
}

function percentToCanvas(coords){
  const x1 = imageDraw.x + (coords.x1 / 100) * imageDraw.w;
  const y1 = imageDraw.y + (coords.y1 / 100) * imageDraw.h;
  const x2 = imageDraw.x + (coords.x2 / 100) * imageDraw.w;
  const y2 = imageDraw.y + (coords.y2 / 100) * imageDraw.h;
  return {x1, y1, x2, y2};
}

function getCanvasCoords(ev){
  const rect = canvas.getBoundingClientRect();
  const px = (ev.clientX - rect.left) * (canvas.width / rect.width);
  const py = (ev.clientY - rect.top) * (canvas.height / rect.height);
  return {px, py};
}

function findRectangleAtPoint(px, py){
  for(let i = rectangles.length - 1; i >= 0; i--){
    const rect = rectangles[i];
    const coords = percentToCanvas(rect.coords);
    if(px >= coords.x1 && px <= coords.x2 && py >= coords.y1 && py <= coords.y2){
      return i;
    }
  }
  return -1;
}

function findResizeHandle(px, py, rectIdx){
  const rect = rectangles[rectIdx];
  const coords = percentToCanvas(rect.coords);
  const hs = RESIZE_HANDLE_SIZE;
  
  // Check each corner
  if(Math.abs(px - coords.x1) < hs && Math.abs(py - coords.y1) < hs) return 'tl';
  if(Math.abs(px - coords.x2) < hs && Math.abs(py - coords.y1) < hs) return 'tr';
  if(Math.abs(px - coords.x1) < hs && Math.abs(py - coords.y2) < hs) return 'bl';
  if(Math.abs(px - coords.x2) < hs && Math.abs(py - coords.y2) < hs) return 'br';
  
  return null;
}

// Canvas mouse events
canvas.addEventListener('mousedown', (ev)=>{
  if(!imgLoaded) return alert('Please upload an image first');
  if(ev.button !== 0) return;
  
  const {px, py} = getCanvasCoords(ev);
  
  if(currentMode === 'setup'){
    // Check if clicking on existing rectangle
    const rectIdx = findRectangleAtPoint(px, py);
    if(rectIdx !== -1){
      // Check if clicking on a resize handle
      const resizeCorner = findResizeHandle(px, py, rectIdx);
      if(resizeCorner){
        // Start resizing
        dragMode = 'resize';
        dragRectIdx = rectIdx;
        dragResizeCorner = resizeCorner;
      } else if(ev.shiftKey){
        // Shift+click to delete
        rectangles.splice(rectIdx, 1);
        // Reassign labels to fill the gap
        rectangles.forEach((rect, idx) => {
          rect.id = labels[idx];
        });
        updateRectangleList();
        redraw();
        return;
      } else {
        // Start moving
        dragMode = 'move';
        dragRectIdx = rectIdx;
        const pct = canvasToPercent(px, py);
        const rect = rectangles[rectIdx];
        dragOffset = {
          x: pct.x - rect.coords.x1,
          y: pct.y - rect.coords.y1
        };
      }
      return;
    }
    
    // Start drawing new rectangle if under limit
    if(rectangles.length < 6){
      isDrawing = true;
      const pct = canvasToPercent(px, py);
      drawStart = {x: pct.x, y: pct.y};
    }
  } else {
    // Play mode: toggle selection
    const rectIdx = findRectangleAtPoint(px, py);
    if(rectIdx !== -1){
      const rectId = rectangles[rectIdx].id;
      if(selectedAnswers.has(rectId)){
        selectedAnswers.delete(rectId);
      } else {
        selectedAnswers.add(rectId);
      }
      updateSelectedDisplay();
      redraw();
    }
  }
});

canvas.addEventListener('mousemove', (ev)=>{
  if(currentMode !== 'setup') return;
  
  const {px, py} = getCanvasCoords(ev);
  const pct = canvasToPercent(px, py);
  
  if(isDrawing){
    // Drawing new rectangle
    tempRect = {
      x1: Math.min(drawStart.x, pct.x),
      y1: Math.min(drawStart.y, pct.y),
      x2: Math.max(drawStart.x, pct.x),
      y2: Math.max(drawStart.y, pct.y)
    };
    redraw();
  } else if(dragMode === 'move' && dragRectIdx !== -1){
    // Moving rectangle
    const rect = rectangles[dragRectIdx];
    const width = rect.coords.x2 - rect.coords.x1;
    const height = rect.coords.y2 - rect.coords.y1;
    
    rect.coords.x1 = Math.max(0, Math.min(100 - width, pct.x - dragOffset.x));
    rect.coords.y1 = Math.max(0, Math.min(100 - height, pct.y - dragOffset.y));
    rect.coords.x2 = rect.coords.x1 + width;
    rect.coords.y2 = rect.coords.y1 + height;
    
    redraw();
  } else if(dragMode === 'resize' && dragRectIdx !== -1){
    // Resizing rectangle
    const rect = rectangles[dragRectIdx];
    
    if(dragResizeCorner === 'tl'){
      rect.coords.x1 = Math.min(pct.x, rect.coords.x2 - 1);
      rect.coords.y1 = Math.min(pct.y, rect.coords.y2 - 1);
    } else if(dragResizeCorner === 'tr'){
      rect.coords.x2 = Math.max(pct.x, rect.coords.x1 + 1);
      rect.coords.y1 = Math.min(pct.y, rect.coords.y2 - 1);
    } else if(dragResizeCorner === 'bl'){
      rect.coords.x1 = Math.min(pct.x, rect.coords.x2 - 1);
      rect.coords.y2 = Math.max(pct.y, rect.coords.y1 + 1);
    } else if(dragResizeCorner === 'br'){
      rect.coords.x2 = Math.max(pct.x, rect.coords.x1 + 1);
      rect.coords.y2 = Math.max(pct.y, rect.coords.y1 + 1);
    }
    
    // Clamp to bounds
    rect.coords.x1 = Math.max(0, Math.min(100, rect.coords.x1));
    rect.coords.y1 = Math.max(0, Math.min(100, rect.coords.y1));
    rect.coords.x2 = Math.max(0, Math.min(100, rect.coords.x2));
    rect.coords.y2 = Math.max(0, Math.min(100, rect.coords.y2));
    
    redraw();
  } else {
    // Update cursor based on what's under mouse
    const rectIdx = findRectangleAtPoint(px, py);
    if(rectIdx !== -1){
      const resizeCorner = findResizeHandle(px, py, rectIdx);
      if(resizeCorner){
        if(resizeCorner === 'tl' || resizeCorner === 'br'){
          canvas.style.cursor = 'nwse-resize';
        } else {
          canvas.style.cursor = 'nesw-resize';
        }
      } else {
        canvas.style.cursor = 'move';
      }
    } else {
      canvas.style.cursor = 'crosshair';
    }
  }
});

canvas.addEventListener('mouseup', (ev)=>{
  if(currentMode !== 'setup') return;
  
  if(isDrawing){
    const {px, py} = getCanvasCoords(ev);
    const pct = canvasToPercent(px, py);
    
    const finalRect = {
      x1: Math.min(drawStart.x, pct.x),
      y1: Math.min(drawStart.y, pct.y),
      x2: Math.max(drawStart.x, pct.x),
      y2: Math.max(drawStart.y, pct.y)
    };
    
    // Only add if rectangle has some size
    const width = Math.abs(finalRect.x2 - finalRect.x1);
    const height = Math.abs(finalRect.y2 - finalRect.y1);
    
    if(width > 1 && height > 1){
      const nextLabel = labels[rectangles.length];
      rectangles.push({
        id: nextLabel,
        coords: finalRect,
        isCorrect: false
      });
      updateRectangleList();
    }
    
    isDrawing = false;
    drawStart = null;
    tempRect = null;
  } else if(dragMode === 'move' || dragMode === 'resize'){
    // End dragging
    dragMode = null;
    dragRectIdx = -1;
    dragResizeCorner = null;
  }
  
  redraw();
});

function updateRectangleList(){
  if(rectangles.length === 0){
    rectangleList.innerHTML = '<div style="font-size:13px;color:#666;font-style:italic">No rectangles drawn yet</div>';
    playQuizBtn.disabled = true;
  } else {
    let html = '';
    rectangles.forEach(rect => {
      html += `
        <div class="rectangle-item">
          <span class="rectangle-label">${rect.id}</span>
          <input type="checkbox" id="check-${rect.id}" ${rect.isCorrect ? 'checked' : ''}>
          <label for="check-${rect.id}" style="margin:0;font-weight:normal;flex:1">Correct answer</label>
          <button onclick="deleteRectangle('${rect.id}')" class="secondary">Delete</button>
        </div>
      `;
    });
    rectangleList.innerHTML = html;
    
    // Add event listeners to checkboxes
    rectangles.forEach(rect => {
      document.getElementById(`check-${rect.id}`).addEventListener('change', (e)=>{
        rect.isCorrect = e.target.checked;
        updatePlayButton();
      });
    });
    
    updatePlayButton();
  }
}

function updatePlayButton(){
  const hasCorrectAnswers = rectangles.some(r => r.isCorrect);
  playQuizBtn.disabled = !hasCorrectAnswers || !questionInput.value.trim();
}

function deleteRectangle(id){
  rectangles = rectangles.filter(r => r.id !== id);
  // Reassign labels to fill the gap
  rectangles.forEach((rect, idx) => {
    rect.id = labels[idx];
  });
  updateRectangleList();
  redraw();
}

function updateSelectedDisplay(){
  if(selectedAnswers.size === 0){
    selectedDisplay.textContent = 'None';
  } else {
    selectedDisplay.textContent = Array.from(selectedAnswers).sort().join(', ');
  }
}

// Button event listeners
questionInput.addEventListener('input', updatePlayButton);

playQuizBtn.addEventListener('click', ()=>{
  currentMode = 'play';
  selectedAnswers.clear();
  quizSubmitted = false;
  correctAnswersSet.clear();
  questionDisplay.textContent = questionInput.value.trim();
  setupMode.style.display = 'none';
  playMode.style.display = 'block';
  quizResult.style.display = 'none';
  canvas.style.cursor = 'pointer';
  updateSelectedDisplay();
  redraw();
});

backToSetupBtn.addEventListener('click', ()=>{
  currentMode = 'setup';
  selectedAnswers.clear();
  quizSubmitted = false;
  correctAnswersSet.clear();
  setupMode.style.display = 'block';
  playMode.style.display = 'none';
  canvas.style.cursor = 'crosshair';
  redraw();
});

clearAllBtn.addEventListener('click', ()=>{
  if(confirm('Clear all rectangles?')){
    rectangles = [];
    updateRectangleList();
    redraw();
  }
});

submitAnswerBtn.addEventListener('click', ()=>{
  const correctAnswers = new Set(rectangles.filter(r => r.isCorrect).map(r => r.id));
  correctAnswersSet = correctAnswers; // Store for color coding
  quizSubmitted = true; // Mark as submitted
  
  const totalCorrect = correctAnswers.size;
  const totalRectangles = rectangles.length;
  
  // Calculate results
  const correctlySelected = Array.from(selectedAnswers).filter(id => correctAnswers.has(id));
  const incorrectlySelected = Array.from(selectedAnswers).filter(id => !correctAnswers.has(id));
  const missed = Array.from(correctAnswers).filter(id => !selectedAnswers.has(id));
  const correctlyAvoided = rectangles.filter(r => !correctAnswers.has(r.id) && !selectedAnswers.has(r.id)).map(r => r.id);
  
  // Score includes both correct selections AND correctly avoided wrong answers
  const score = correctlySelected.length + correctlyAvoided.length;
  
  // Display results
  let resultClass = 'fail';
  let resultText = '';
  
  if(score === totalRectangles && incorrectlySelected.length === 0 && missed.length === 0){
    resultClass = '';
    resultText = `ðŸŽ‰ Perfect! You got all ${totalRectangles} rectangles correct!`;
  } else if(score > 0){
    resultClass = 'partial';
    resultText = `You got ${score} out of ${totalRectangles} rectangles correct.`;
  } else {
    resultClass = 'fail';
    resultText = `You got 0 out of ${totalRectangles} rectangles correct.`;
  }
  
  let detailsHtml = '<div class="answer-status">';
  if(correctlySelected.length > 0){
    detailsHtml += `<div class="correct">âœ“ Correctly selected: ${correctlySelected.join(', ')}</div>`;
  }
  if(correctlyAvoided.length > 0){
    detailsHtml += `<div class="correct">âœ“ Correctly avoided: ${correctlyAvoided.join(', ')}</div>`;
  }
  if(incorrectlySelected.length > 0){
    detailsHtml += `<div class="incorrect">âœ— Wrong: ${incorrectlySelected.join(', ')}</div>`;
  }
  if(missed.length > 0){
    detailsHtml += `<div class="missed">â—‹ Missed: ${missed.join(', ')}</div>`;
  }
  detailsHtml += '</div>';
  
  detailsHtml += `<div class="correct-answers"><strong>Correct answers were:</strong> ${Array.from(correctAnswers).sort().join(', ')}</div>`;
  
  quizResult.className = 'quiz-result ' + resultClass;
  quizResult.innerHTML = `<div style="font-size:18px;font-weight:600;margin-bottom:8px">${resultText}</div>${detailsHtml}`;
  quizResult.style.display = 'block';
  
  // Redraw to show color-coded rectangles
  redraw();
});

// Initial state
updateRectangleList();
</script>
</body>
</html>
